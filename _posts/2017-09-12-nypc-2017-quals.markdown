---
title: "NYPC 2017 예선대회 후기"
layout: post
date: 2017-09-12 20:21
image: https://koppl.in/indigo/assets/images/jekyll-logo-light-solid.png
headerImage: false
projects: false
author: simotion
tags: ["NYPC", "Algorithm"]
---
## 스테이지 1
#### 101: 파리의 이동 거리 (100/100)
두 기차와 파리의 이동 속력을 가지고 충돌 시간을 구한 후, 그걸로 잘 쪼개서 풀었다(...) 몇 번 시행착오 해서 풀은듯.

#### 102: 캠프파이어 (150/150)
naive하게 풀었다. 이차원 배열 잡아서 뚝딱..

#### 103: 은는이가을를 (0/200)
정말 시간을 많이 썼는데 풀지는 못한 문제다. 순서대로 탐색해 가면서 해보려고 했는데, 이상하게 제출하면 틀렸다. 파이썬으로 문제를 거의 안풀어봤는데, 앞으로 좀 더 풀어봐야겠다.

#### 104: 로드러너 1 경비로봇 인공지능 제작 (150/300)
BFS에 priority queue를 섞어서 풀어보려고 했는데, 마지막 케이스에서 계속 오답이 났다. 시간 초과는 나지 않는걸 보니 조건을 하나 빼먹은 것 같다.

#### 105: 기숙사 (450/450)
원래 방 배치, 바꿔야 할 방 배치를 각각 후위 순회, 살짝 바꾼 중위 순회로 돌아 각 번호의 시작/끝 위치를 파악하고, LCA로 최단 경로를 찾았다. 중위 순회를 살짝 바꾼 것은 자고 있는 방일 경우 건너뛰고, 자고 있는 번호일 경우 그 번호를 건너뛰는 방식이다. 문제를 이해하기 힘들어서 그렇지 생각보다 어렵지는 않았다.

## 스테이지 2
#### 201: 알사탕 (80/80)
한 사람이 왼쪽만, 다른 사람만 오른쪽만 먹는다고 해도 문제가 없다. 그러니 주어지는 문자열을 [0:int((n+1)/2)]로 잘라서 출력하면 된다.

#### 202: 아이템 거리 (170/170)
string과 set을 이용해서 만드는 구현 문제였다. 만점이 안나오길래 처음부터 다시 짰더니 만점을 받았다. 어디선가 실수가 있었는듯..

#### 203: 벽돌깨기 (200/200)
만들고 싶은 순서의 내림차순으로 벽돌들을 정렬하고, 순서대로 (이전 벽돌 높이)-1이 되도록 하는 개수들을 구하고, 도중 음수가 나오면 불가능한 것으로 판단했다.

#### 204: 개구리 점프 (350/350)
다익스트라 비슷하게 했다. 각 막대기를 정점으로 보고, 현재 시간에서 얼마나 기다려야 다른 막대기로 옮겨갈 수 있는지를 간선의 가중치로 보고 풀었다.

#### 205: 대포 (400/400)
풀어놓고도 이게 풀리나.. 싶었던 풀이긴 한데 다시 생각해봐도 논리적으로 틀린 부분은 없는 것 같다. 먼저 각 대포에 대해 \방향, /방향의 인덱스를 구해 정렬한다. 즉, 공간의 너비를 w라 하면 (i,j)에 위치한 점의 인덱스는 각각 i+j, i+(w-j)가 되는 것이다. 그렇게 하고

> - 내 팀의 / 최소와 상대 팀의 \ 최대의 차 <br>
> - 내 팀의 / 최대와 상대 팀의 \ 최소의 차 <br>
> - 내 팀의 \ 최소와 상대 팀의 / 최대의 차 <br>
> - 내 팀의 \ 최대와 상태 팀의 / 최소의 차 <br>

4가지 중 가장 큰 것이 정답이 된다.

## 스테이지 3
#### 301: 파란색 영역 (102/102)
임의의 두 정사각형이 만나는지를 판정해 그래프를 구성하고, 몇 개의 그룹이 나오는지를 탐색했다.

#### 302: 타일 맞추기 (133.33/150)
주어진 패턴대로 전체 탐색을 하거나 BFS를 써서 풀..려고 했다. 그런데 처음 제출한 정답이 네번 재채점 되면서 100->150->80->133.33점이 되니까 별로 풀 마음이 안들어서 포기했다.

#### 303: 알사탕2 (200/200)
DP 식을 만드는 건 쉬웠는데, 문제는 메모리였다. 남은 사탕들이 연속하고, 길이가 단계마다 일정한 점을 이용해서 공간복잡도 n^2 정도로 압축했는데도 메모리 제한을 살짝 넘었다 (8MB). 그래서 가능한 패턴인지의 여부만 표현하면 되니 unsigned long long을 이용해서 비트로 압축했다.

#### 304: 개미와 보도블럭 (350/350)
한 블럭에서 다른 블럭까지의 거리를 구하는 과정이 오래 걸렸다. 세로 인덱스의 기우성에 따라 식이 달라졌는데, 생각하는 것도 오래 걸리고 코딩도 시간이 걸렸다. 그걸 해결하고 나서는 사라진 막대기들의 인덱스를 x축에 대해 정렬하고, dp[i]=(i번째 사라진 막대의 위치에서 최단 거리)로 정의했다. 그리고 dp[i]=min(dist(i,i+1)+dp[i+1],...,dist(i,n-1)+dp[n-1])로 돌렸다. 그런 후 처음 정담을 사라진 막대기를 고려하지 않고 시작점과 끝점까지의 거리로 잡고, dist(i,0)+dp[0], ..., dist(i,n-1)+dp[n-1] 중 최소값과 비교해 정답으로 했다.

#### 305: 한꺼번에 길찾기 (46정도?/750)
점수 조금만 따려고 한 턴에 하나만 이동하게 짰는데, 정말 조금만 나왔다.. 본선에서 이런 문제 안나왔으면ㅜㅜ